// Code generated by mockery v2.53.5. DO NOT EDIT.

package common

import mock "github.com/stretchr/testify/mock"

// MockITxnLoggerWithContext is an autogenerated mock type for the ITxnLoggerWithContext type
type MockITxnLoggerWithContext struct {
	mock.Mock
}

type MockITxnLoggerWithContext_Expecter struct {
	mock *mock.Mock
}

func (_m *MockITxnLoggerWithContext) EXPECT() *MockITxnLoggerWithContext_Expecter {
	return &MockITxnLoggerWithContext_Expecter{mock: &_m.Mock}
}

// AppendAbort provides a mock function with no fields
func (_m *MockITxnLoggerWithContext) AppendAbort() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AppendAbort")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockITxnLoggerWithContext_AppendAbort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendAbort'
type MockITxnLoggerWithContext_AppendAbort_Call struct {
	*mock.Call
}

// AppendAbort is a helper method to define mock.On call
func (_e *MockITxnLoggerWithContext_Expecter) AppendAbort() *MockITxnLoggerWithContext_AppendAbort_Call {
	return &MockITxnLoggerWithContext_AppendAbort_Call{Call: _e.mock.On("AppendAbort")}
}

func (_c *MockITxnLoggerWithContext_AppendAbort_Call) Run(run func()) *MockITxnLoggerWithContext_AppendAbort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendAbort_Call) Return(_a0 error) *MockITxnLoggerWithContext_AppendAbort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendAbort_Call) RunAndReturn(run func() error) *MockITxnLoggerWithContext_AppendAbort_Call {
	_c.Call.Return(run)
	return _c
}

// AppendBegin provides a mock function with no fields
func (_m *MockITxnLoggerWithContext) AppendBegin() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AppendBegin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockITxnLoggerWithContext_AppendBegin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendBegin'
type MockITxnLoggerWithContext_AppendBegin_Call struct {
	*mock.Call
}

// AppendBegin is a helper method to define mock.On call
func (_e *MockITxnLoggerWithContext_Expecter) AppendBegin() *MockITxnLoggerWithContext_AppendBegin_Call {
	return &MockITxnLoggerWithContext_AppendBegin_Call{Call: _e.mock.On("AppendBegin")}
}

func (_c *MockITxnLoggerWithContext_AppendBegin_Call) Run(run func()) *MockITxnLoggerWithContext_AppendBegin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendBegin_Call) Return(_a0 error) *MockITxnLoggerWithContext_AppendBegin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendBegin_Call) RunAndReturn(run func() error) *MockITxnLoggerWithContext_AppendBegin_Call {
	_c.Call.Return(run)
	return _c
}

// AppendCommit provides a mock function with no fields
func (_m *MockITxnLoggerWithContext) AppendCommit() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AppendCommit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockITxnLoggerWithContext_AppendCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendCommit'
type MockITxnLoggerWithContext_AppendCommit_Call struct {
	*mock.Call
}

// AppendCommit is a helper method to define mock.On call
func (_e *MockITxnLoggerWithContext_Expecter) AppendCommit() *MockITxnLoggerWithContext_AppendCommit_Call {
	return &MockITxnLoggerWithContext_AppendCommit_Call{Call: _e.mock.On("AppendCommit")}
}

func (_c *MockITxnLoggerWithContext_AppendCommit_Call) Run(run func()) *MockITxnLoggerWithContext_AppendCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendCommit_Call) Return(_a0 error) *MockITxnLoggerWithContext_AppendCommit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendCommit_Call) RunAndReturn(run func() error) *MockITxnLoggerWithContext_AppendCommit_Call {
	_c.Call.Return(run)
	return _c
}

// AppendDelete provides a mock function with given fields: recordID
func (_m *MockITxnLoggerWithContext) AppendDelete(recordID RecordID) (LogRecordLocInfo, error) {
	ret := _m.Called(recordID)

	if len(ret) == 0 {
		panic("no return value specified for AppendDelete")
	}

	var r0 LogRecordLocInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(RecordID) (LogRecordLocInfo, error)); ok {
		return rf(recordID)
	}
	if rf, ok := ret.Get(0).(func(RecordID) LogRecordLocInfo); ok {
		r0 = rf(recordID)
	} else {
		r0 = ret.Get(0).(LogRecordLocInfo)
	}

	if rf, ok := ret.Get(1).(func(RecordID) error); ok {
		r1 = rf(recordID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockITxnLoggerWithContext_AppendDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendDelete'
type MockITxnLoggerWithContext_AppendDelete_Call struct {
	*mock.Call
}

// AppendDelete is a helper method to define mock.On call
//   - recordID RecordID
func (_e *MockITxnLoggerWithContext_Expecter) AppendDelete(recordID interface{}) *MockITxnLoggerWithContext_AppendDelete_Call {
	return &MockITxnLoggerWithContext_AppendDelete_Call{Call: _e.mock.On("AppendDelete", recordID)}
}

func (_c *MockITxnLoggerWithContext_AppendDelete_Call) Run(run func(recordID RecordID)) *MockITxnLoggerWithContext_AppendDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(RecordID))
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendDelete_Call) Return(_a0 LogRecordLocInfo, _a1 error) *MockITxnLoggerWithContext_AppendDelete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendDelete_Call) RunAndReturn(run func(RecordID) (LogRecordLocInfo, error)) *MockITxnLoggerWithContext_AppendDelete_Call {
	_c.Call.Return(run)
	return _c
}

// AppendInsert provides a mock function with given fields: recordID, value
func (_m *MockITxnLoggerWithContext) AppendInsert(recordID RecordID, value []byte) (LogRecordLocInfo, error) {
	ret := _m.Called(recordID, value)

	if len(ret) == 0 {
		panic("no return value specified for AppendInsert")
	}

	var r0 LogRecordLocInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(RecordID, []byte) (LogRecordLocInfo, error)); ok {
		return rf(recordID, value)
	}
	if rf, ok := ret.Get(0).(func(RecordID, []byte) LogRecordLocInfo); ok {
		r0 = rf(recordID, value)
	} else {
		r0 = ret.Get(0).(LogRecordLocInfo)
	}

	if rf, ok := ret.Get(1).(func(RecordID, []byte) error); ok {
		r1 = rf(recordID, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockITxnLoggerWithContext_AppendInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendInsert'
type MockITxnLoggerWithContext_AppendInsert_Call struct {
	*mock.Call
}

// AppendInsert is a helper method to define mock.On call
//   - recordID RecordID
//   - value []byte
func (_e *MockITxnLoggerWithContext_Expecter) AppendInsert(recordID interface{}, value interface{}) *MockITxnLoggerWithContext_AppendInsert_Call {
	return &MockITxnLoggerWithContext_AppendInsert_Call{Call: _e.mock.On("AppendInsert", recordID, value)}
}

func (_c *MockITxnLoggerWithContext_AppendInsert_Call) Run(run func(recordID RecordID, value []byte)) *MockITxnLoggerWithContext_AppendInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(RecordID), args[1].([]byte))
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendInsert_Call) Return(_a0 LogRecordLocInfo, _a1 error) *MockITxnLoggerWithContext_AppendInsert_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendInsert_Call) RunAndReturn(run func(RecordID, []byte) (LogRecordLocInfo, error)) *MockITxnLoggerWithContext_AppendInsert_Call {
	_c.Call.Return(run)
	return _c
}

// AppendTxnEnd provides a mock function with no fields
func (_m *MockITxnLoggerWithContext) AppendTxnEnd() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AppendTxnEnd")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockITxnLoggerWithContext_AppendTxnEnd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendTxnEnd'
type MockITxnLoggerWithContext_AppendTxnEnd_Call struct {
	*mock.Call
}

// AppendTxnEnd is a helper method to define mock.On call
func (_e *MockITxnLoggerWithContext_Expecter) AppendTxnEnd() *MockITxnLoggerWithContext_AppendTxnEnd_Call {
	return &MockITxnLoggerWithContext_AppendTxnEnd_Call{Call: _e.mock.On("AppendTxnEnd")}
}

func (_c *MockITxnLoggerWithContext_AppendTxnEnd_Call) Run(run func()) *MockITxnLoggerWithContext_AppendTxnEnd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendTxnEnd_Call) Return(_a0 error) *MockITxnLoggerWithContext_AppendTxnEnd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendTxnEnd_Call) RunAndReturn(run func() error) *MockITxnLoggerWithContext_AppendTxnEnd_Call {
	_c.Call.Return(run)
	return _c
}

// AppendUpdate provides a mock function with given fields: recordID, before, after
func (_m *MockITxnLoggerWithContext) AppendUpdate(recordID RecordID, before []byte, after []byte) (LogRecordLocInfo, error) {
	ret := _m.Called(recordID, before, after)

	if len(ret) == 0 {
		panic("no return value specified for AppendUpdate")
	}

	var r0 LogRecordLocInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(RecordID, []byte, []byte) (LogRecordLocInfo, error)); ok {
		return rf(recordID, before, after)
	}
	if rf, ok := ret.Get(0).(func(RecordID, []byte, []byte) LogRecordLocInfo); ok {
		r0 = rf(recordID, before, after)
	} else {
		r0 = ret.Get(0).(LogRecordLocInfo)
	}

	if rf, ok := ret.Get(1).(func(RecordID, []byte, []byte) error); ok {
		r1 = rf(recordID, before, after)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockITxnLoggerWithContext_AppendUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendUpdate'
type MockITxnLoggerWithContext_AppendUpdate_Call struct {
	*mock.Call
}

// AppendUpdate is a helper method to define mock.On call
//   - recordID RecordID
//   - before []byte
//   - after []byte
func (_e *MockITxnLoggerWithContext_Expecter) AppendUpdate(recordID interface{}, before interface{}, after interface{}) *MockITxnLoggerWithContext_AppendUpdate_Call {
	return &MockITxnLoggerWithContext_AppendUpdate_Call{Call: _e.mock.On("AppendUpdate", recordID, before, after)}
}

func (_c *MockITxnLoggerWithContext_AppendUpdate_Call) Run(run func(recordID RecordID, before []byte, after []byte)) *MockITxnLoggerWithContext_AppendUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(RecordID), args[1].([]byte), args[2].([]byte))
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendUpdate_Call) Return(_a0 LogRecordLocInfo, _a1 error) *MockITxnLoggerWithContext_AppendUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockITxnLoggerWithContext_AppendUpdate_Call) RunAndReturn(run func(RecordID, []byte, []byte) (LogRecordLocInfo, error)) *MockITxnLoggerWithContext_AppendUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GetTxnID provides a mock function with no fields
func (_m *MockITxnLoggerWithContext) GetTxnID() TxnID {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTxnID")
	}

	var r0 TxnID
	if rf, ok := ret.Get(0).(func() TxnID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(TxnID)
	}

	return r0
}

// MockITxnLoggerWithContext_GetTxnID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTxnID'
type MockITxnLoggerWithContext_GetTxnID_Call struct {
	*mock.Call
}

// GetTxnID is a helper method to define mock.On call
func (_e *MockITxnLoggerWithContext_Expecter) GetTxnID() *MockITxnLoggerWithContext_GetTxnID_Call {
	return &MockITxnLoggerWithContext_GetTxnID_Call{Call: _e.mock.On("GetTxnID")}
}

func (_c *MockITxnLoggerWithContext_GetTxnID_Call) Run(run func()) *MockITxnLoggerWithContext_GetTxnID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_GetTxnID_Call) Return(_a0 TxnID) *MockITxnLoggerWithContext_GetTxnID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockITxnLoggerWithContext_GetTxnID_Call) RunAndReturn(run func() TxnID) *MockITxnLoggerWithContext_GetTxnID_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with no fields
func (_m *MockITxnLoggerWithContext) Rollback() {
	_m.Called()
}

// MockITxnLoggerWithContext_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type MockITxnLoggerWithContext_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
func (_e *MockITxnLoggerWithContext_Expecter) Rollback() *MockITxnLoggerWithContext_Rollback_Call {
	return &MockITxnLoggerWithContext_Rollback_Call{Call: _e.mock.On("Rollback")}
}

func (_c *MockITxnLoggerWithContext_Rollback_Call) Run(run func()) *MockITxnLoggerWithContext_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockITxnLoggerWithContext_Rollback_Call) Return() *MockITxnLoggerWithContext_Rollback_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockITxnLoggerWithContext_Rollback_Call) RunAndReturn(run func()) *MockITxnLoggerWithContext_Rollback_Call {
	_c.Run(run)
	return _c
}

// NewMockITxnLoggerWithContext creates a new instance of MockITxnLoggerWithContext. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockITxnLoggerWithContext(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockITxnLoggerWithContext {
	mock := &MockITxnLoggerWithContext{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
