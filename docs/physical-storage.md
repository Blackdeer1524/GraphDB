# Физическое хранение данных

## Vertex

Вершины будет храниться в следующем виде. Вершины разных типов будут храниться в отдельных файлах.

Вершина состоит из:
- 1 байт на статус (удалена/нет)
- `ID` вершины
- `EdgeBlockDirectoryID`
- `PropertiesID` (а может тоже, как и ребра будем хранить прямо в инстансе вершины?)


## Directory

Для повышения локальности обхода была введена абстракция `Directory`. Идея состоит в том, что хотелось бы сначала обходить все ребра одного типа, потом ребра другого и так далее.

Ребра разного типа в `Directory` абстрагированы блоками. То есть за ребро определённого типа будет отвечать блок.

Блок состоит из:
- `ID` блока
- типа ребра, за который он отвечает 
- `FirstEdgeID` (id первого ребра из вершины с VertexID данного типа) 
- `ID` следующего блока данной вершины


Данные будут храниться в hash индексе для повышения скорости запроса.


## Edge

Ребра разного типа будут храниться в разных файлах. Ребра состоят из:
- `ID` ребра
- свойства ребра
- `ID` следующего ребра данной вершины

## Свойства

## Общая схема
Для упрощения тут указаны не все поля. Также на схеме нет ничего про свойства

![alt text](scheme.jpg)

# Почему отказались от прямых указателей на данные?

# Запросы

### Запрос 1

Выбор вершин: обход DFS/BFS c фильтрацией по вершинам на пути (если она есть, то по временной метке – timestamp); выход – набор листовых вершин на заданной глубине.

```pseudo
```

### Запрос 2

Выбор всех вершин с заданным значением поля.

```pseudo
```

### Запрос 3

(расширенный п.2) Выбор всех вершин с заданным значением поля + фильтр по связям (степень вершины с учётом условия на связи данной вершины).


```pseudo
```

### Запрос 4

Подсчёт для каждой вершины суммы некоторого параметра по всем соседним вершинам с ограничением на связь/значение параметра (например, учитывать значение в сумме, если оно превышает некоторый порог).

```pseudo
```

### Запрос 5

Подсчёт всех «треугольников» в графе (без учёта ориентации).

```pseudo
```